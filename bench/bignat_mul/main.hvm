// bignat_mul/main.hvm
// ===================
// Pure functional big-integer multiplication over U32 limbs.
// Manual port of bench/bignat_mul/main.bend.

// Config
// ------

// Returns limb base (2^15).
@base_u32 = 32768

// Utils
// -----

// Converts U32 (0 / nonzero) to Bool.
@u2b = λ{
  0:
    #F{};
  λ&x.
    #T{}
}

// Advances the linear-congruential generator state.
@rng = λ&sed.
  sed * 1664525 + 1013904223

// Bigint Build
// ------------

// Builds a pseudo-random bigint with `len` limbs.
@gen = λ&len. λ&sed.
  ! done = @u2b(len == 0);
  @gen_go(done, len, sed)

// Builds one limb and recurs.
@gen_go = λ{
  #T: λ&len. λ&sed.
    #nil{};
  #F: λ&len. λ&sed.
    ! &sed = @rng(sed);
    ! limb = sed % @base_u32;
    ! len  = len - 1;
    #cons{limb, @gen(len, sed)}
}

// Bigint Add
// ----------

// Adds two limb lists with carry.
@add = λ&xs. λ&ys. λ&car.
  @add_l(xs, ys, car)

// Handles left-focused add recursion.
@add_l = λ{
  #nil: λ&ys. λ&car.
    @add_nil(ys, car);
  #cons: λ&x. λ&xt. λ&ys. λ&car.
    @add_pair(x, xt, ys, car)
}

// Handles pairwise addition when left list is non-empty.
@add_pair = λ&x. λ&xt. λ{
  #nil: λ&car.
    @add_one(x, xt, car);
  #cons: λ&y. λ&yt. λ&car.
    ! &s = x + y + car;
    ! &b = @base_u32;
    ! d  = s % b;
    ! c  = s / b;
    #cons{d, @add(xt, yt, c)}
}

// Adds carry into an empty-left case.
@add_nil = λ{
  #nil: λ&car.
    @add_end(car);
  #cons: λ&y. λ&yt. λ&car.
    @add_one(y, yt, car)
}

// Adds one limb plus carry, then recurs.
@add_one = λ&x. λ&xt. λ&car.
  ! &s = x + car;
  ! &b = @base_u32;
  ! d  = s % b;
  ! c  = s / b;
  #cons{d, @add(xt, #nil{}, c)}

// Emits final carry if nonzero.
@add_end = λ&car.
  ! done = @u2b(car == 0);
  @add_end_go(done, car)

// Dispatches final carry emission.
@add_end_go = λ{
  #T: λ&car.
    #nil{};
  #F: λ&car.
    #cons{car, #nil{}}
}

// Bigint Mul
// ----------

// Multiplies a limb list by one scalar limb with carry.
@mul_scalar = λ{
  #nil: λ&k. λ&car.
    @add_end(car);
  #cons: λ&x. λ&xt. λ&k. λ&car.
    ! &p = x * k + car;
    ! &b = @base_u32;
    ! d  = p % b;
    ! c  = p / b;
    #cons{d, @mul_scalar(xt, k, c)}
}

// Prepends `n` zero limbs.
@shift = λ&xs. λ&n.
  ! done = @u2b(n == 0);
  @shift_go(done, xs, n)

// Dispatches zero/nonzero shift depth.
@shift_go = λ{
  #T: λ&xs. λ&n.
    xs;
  #F: λ&xs. λ&n.
    ! n = n - 1;
    #cons{0, @shift(xs, n)}
}

// Accumulates schoolbook rows for full multiplication.
@mul_rows = λ{
  #nil: λ&bs. λ&sh. λ&acc.
    acc;
  #cons: λ&a. λ&at. λ&bs. λ&sh. λ&acc.
    ! row = @mul_scalar(bs, a, 0);
    ! row = @shift(row, sh);
    ! acc = @add(acc, row, 0);
    ! sh  = sh + 1;
    @mul_rows(at, bs, sh, acc)
}

// Multiplies two bigints.
@mul = λ&as. λ&bs.
  @mul_rows(as, bs, 0, #nil{})

// Hash
// ----

// Folds a limb list into a U32 checksum.
@hash = λ{
  #nil: λ&acc.
    acc;
  #cons: λ&x. λ&xt. λ&acc.
    ! acc = (acc ^ x) * 16777619 + 2166136261;
    @hash(xt, acc)
}

// Benchmark
// ---------

// Runs one multiplication-heavy round.
@round = λ&seed. λ&acc.
  ! &a_seed = @rng(seed);
  ! &b_seed = @rng(a_seed);
  ! &c_seed = @rng(b_seed);
  ! a       = @gen(96, a_seed);
  ! &b      = @gen(96, b_seed);
  ! c       = @gen(96, c_seed);
  ! p       = @mul(a, b);
  ! q       = @mul(b, c);
  ! acc     = @hash(p, acc ^ seed);
  ! acc     = @hash(q, acc);
  ! seed    = @rng(c_seed);
  #st{seed, acc}

// Runs one round from a benchmark state.
@round_st = λ{
  #st: λ&seed. λ&acc.
    @round(seed, acc)
}

// Runs benchmark rounds.
@bench = λ&rounds. λ&seed. λ&acc.
  ! done = @u2b(rounds == 0);
  @bench_go(done, rounds, seed, acc)

// Performs four rounds per recursion step.
@bench_go = λ{
  #T: λ&rounds. λ&seed. λ&acc.
    acc;
  #F: λ&rounds. λ&seed. λ&acc.
    ! s      = @round(seed, acc);
    ! s      = @round_st(s);
    ! s      = @round_st(s);
    ! s      = @round_st(s);
    ! rounds = rounds - 1;
    @bench_take(rounds, s)
}

// Continues benchmark recursion from a state pair.
@bench_take = λ&rounds. λ{
  #st: λ&seed. λ&acc.
    @bench(rounds, seed, acc)
}

// Main
// ----

// Evaluates the benchmark with the shared tuned input.
@main = @bench(7, 1, 0)
